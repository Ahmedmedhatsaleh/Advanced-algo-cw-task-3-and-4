#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
struct Node {
    string key;
    Node* left;
    Node* right;
    int height;
    Node(string k) : key(k), left(nullptr), right(nullptr), height(1) {}
};
class mainavltree {
public:
    Node* insert(Node* node, const string& key) {
        if (!node) return new Node(key);
        if (key < node->key)
            node->left = insert(node->left, key);
        else if (key > node->key)
            node->right = insert(node->right, key);
        else
            return node; 
        node->height = 1 + max(height(node->left), height(node->right));
        int b = balance(node);
        if (b > 1 && key < node->left->key)
            return rightRotate(node);
        if (b < -1 && key > node->right->key)
            return leftRotate(node);
        if (b > 1 && key > node->left->key) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }
        if (b < -1 && key < node->right->key) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }
        return node;
    }
    vector<string> FIND_ALL_WITH_PREFIX(Node* root, const string& prefix) {
        vector<string> results;
        Node* start = root;
        while (start) {
            if (start->key.compare(0, prefix.size(), prefix) < 0)
                start = start->right;
            else if (start->key.compare(0, prefix.size(), prefix) > 0)
                start = start->left;
            else
                break;
        }
        prefixCollection(start, prefix, results);
        sort(results.begin(), results.end());
        return results;
    }
private:
    int height(Node* n) { return n ? n->height : 0; }
    int balance(Node* n) { return n ? height(n->left) - height(n->right) : 0; }
    Node* rightRotate(Node* y) {
        Node* x = y->left;
        Node* T2 = x->right;
        x->right = y;
        y->left = T2;
        y->height = 1 + max(height(y->left), height(y->right));
        x->height = 1 + max(height(x->left), height(x->right));
        return x;
    }
    Node* leftRotate(Node* x) {
        Node* y = x->right;
        Node* T2 = y->left;
        y->left = x;
        x->right = T2;
        x->height = 1 + max(height(x->left), height(x->right));
        y->height = 1 + max(height(y->left), height(y->right));
        return y;
    }
    void prefixCollection(Node* root, const string& prefix, vector<string>& results) {
        if (!root) return;
        if (root->key.compare(0, prefix.size(), prefix) >= 0)
            prefixCollection(root->left, prefix, results);
        if (root->key.compare(0, prefix.size(), prefix) == 0)
            results.push_back(root->key);
        string nextPrefix = prefix;
        nextPrefix.push_back(char(127)); 
        if (root->key.compare(0, prefix.size(), nextPrefix.substr(0, prefix.size())) <= 0)
            prefixCollection(root->right, prefix, results);
    }
};
int main() {
    mainavltree tree;
    Node* root = nullptr;
    vector<string> dictionary = {
       "ace, ", "act, ", "action, ", "active, ", "actor, ", "add, ", "address, ", "admin, ", "advantage, ", "and, ",
       "back, ", "background, ", "backup, ", "balance, ", "ball, ", "ban, ", "band, ", "bank, ", "bar, ", "base, ",
       "call, ", "camp, ", "cat, ", "catch, ", "compile, ", "compiler, ", "compute, ", "computer, ", "computing, ", "constant, ",
       "data, ", "database, ", "date, ", "day, ", "deal, ", "debug, ", "debugger, ", "delete, ", "demo, ", "develop, ",
       "edit, ", "editor, ", "effect, ", "element, ", "email, ", "engine, ", "engineer, ", "enter, ", "entry, ", "error, ",
       "face, ", "factor, ", "fail, ", "false, ", "fast, ", "file, ", "files, ", "filesystem, ", "filter, ", "find, ",
       "game, ", "gate, ", "generate, ", "generic, ", "get, ", "git, ", "github, ", "global, ", "go, ", "graph, ",
       "hand, ", "handle, ", "handler, ", "hash, ", "hashtag, ", "head, ", "header, ", "heap, ", "help, ", "host, ",
       "icon, ", "id, ", "if, ", "image, ", "import, ", "in, ", "index, ", "init, ", "input, ", "install, ",
       "jar, ", "java, ", "javascript, ", "job, ", "join, ", "journal, ", "journey, ", "joy, ", "json, ", "jump, ",
       "key, ", "keyboard, ", "keydown, ", "keyframe, ", "keynote, ", "keypad, ", "keystore, ", "keyup, ", "keyword, ", "keys, ",
       "label, ", "last, ", "layer, ", "layout, ", "lead, ", "learn, ", "left, ", "link, ", "list, ", "load, ",
       "macro, ", "mail, ", "main, ", "manage, ", "manager, ", "map, ", "margin, ", "master, ", "memory, ", "merge, ",
       "name, ", "namespace, ", "nav, ", "navigate, ", "navigation, ", "net, ", "network, ", "new, ", "node, ", "note, ",
       "object, ", "observe, ", "observer, ", "offline, ", "online, ", "open, ", "operator, ", "option, ", "order, ", "output, ",
       "pack, ", "package, ", "packet, ", "page, ", "parallel, ", "parameter, ", "parse, ", "parser, ", "path, ", "post, ",
       "query, ", "question, ", "queue, ", "quick, ", "quicksort, ", "quiet, ", "quit, ", "quiz, ", "quota, ", "quote, ",
       "race, ", "radio, ", "range, ", "rank, ", "react, ", "read, ", "record, ", "recursive, ", "refactor, ", "register, ",
       "save, ", "scan, ", "scanner, ", "scope, ", "screen, ", "script, ", "scroll, ", "search, ", "server, ", "stack, ",
       "table, ", "tag, ", "target, ", "task, ", "team, ", "temp, ", "template, ", "test, ", "testing, ", "text, ",
       "ui, ", "unit, ", "unittest, ", "unix, ", "update, ", "upgrade, ", "upload, ", "url, ", "user, ", "username, ",
       "val, ", "validate, ", "validation, ", "value, ", "var, ", "variable, ", "vector, ", "version, ", "view, ", "virtual, ",
       "wait, ", "warn, ", "warning, ", "web, ", "webhook, ", "webkit, ", "webpack, ", "website, ", "while, ", "window, ",
       "xml, ", "xmlns, ", "xor, ", "xpath, ", "xquery, ", "xref, ", "xss, ", "xsl, ", "xslt, ", "x-axis, ",
       "yacht, ", "yard, ", "yarn, ", "year, ", "yearly, ", "yellow, ", "yesterday, ", "yield, ", "you, ", "your, ",
       "zero, ", "zebra, ", "zip, ", "zipper, ", "zigzag, ", "zone, ", "zombie, ", "zoom, ", "zoomin, ", "zoomout, "
    };
    for (const auto& word : dictionary)
        root = tree.insert(root, word);
    string prefix;
    while (true) {
        cout << "Enter your word: ";
        getline(cin, prefix);
        if (prefix.empty()) break;
        vector<string> results = tree.FIND_ALL_WITH_PREFIX(root, prefix);
        if (!results.empty()) {
            cout << "Suggested words you might be looking for: ";
            for (const auto& w : results)
                cout << w << " ";
            cout << endl;
        } else {
            cout << "No words found." << endl;
        }
    }
    return 0;
}
